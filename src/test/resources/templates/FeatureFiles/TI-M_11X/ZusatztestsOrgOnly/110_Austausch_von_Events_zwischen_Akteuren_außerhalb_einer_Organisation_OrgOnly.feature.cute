#  language: de
@File:FeatureFile_10_OrgOnly
@PRODUKT:TIM_FD @PRODUKT:TIM_Client
@AF-ID:AF_10063
@AK-ID:ML-123670 @AK-ID:ML-123669 @AK-ID:ML-132591
@AF-ID:AF_10104-01
@AK-ID:ML-123896 @AK-ID:ML-129415 @AK-ID:ML-129414 @AK-ID:ML-132590
@AF-ID:AF_10064-01
@AK-ID:ML-123672 @AK-ID:ML-123891 @AK-ID:ML-132589 @AK-ID:ML-137902
@AF-ID:AF_10058-01
@AK-ID:ML-123612 @AK-ID:ML-132588
@AF-ID:AF_10059-01
@AK-ID:ML-123627 @AK-ID:ML-132586
@AK-ID:ML-123654
@AF-ID:AF_10036
Funktionalität: 10. Austausch von Events zwischen Akteuren außerhalb einer Organisation_OrgOnly

  AF_10063 - Austausch von Events zwischen Akteuren innerhalb einer Organisation
  ML-123670 - Chatnachricht wird verarbeitet
  ML-123669 - Auslösen einer Benachrichtigung
  ML-132591 - TI-M Rohdatenerfassung und -lieferung

  Zusätzlich werden in diesem Feature File folgende Anforderungen aus anderen Feature Files betrachtet,
  da sie Preconditions für den AF_10063 darstellen:

  AF_10104-01 - Einladung von Akteuren innerhalb einer Organisation
  ML-123896 - Matrix-Homeserver nach Akteuren durchsuchen
  ML-129415 - Messenger-Proxy prüft TI-Föderationszugehörigkeit
  ML-129414 - Akteure sind dem Chatraum beigetreten
  ML-132590 - TI-M Rohdatenerfassung und -lieferung

  AF_10064-01 - Föderationszugehörigkeit eines Messenger-Service prüfen
  ML-123672 - Föderationsliste vom VZD-FHIR-Directory abrufen
  ML-123891 - Matrix-Domain Teil der Föderationsliste & Aktualitätscheck
  ML-132589 - TI-M Rohdatenerfassung und -lieferung
  ML-137902 - Aktualität - Föderationsliste Messenger-Proxy

  AF_10058-01 - Akteur (User-HBA) im Verzeichnisdienst hinzufügen
  ML-123612 - Akteur als Practitioner hinzufügen
  ML-132588 - TI-M Rohdatenerfassung und -lieferung

  AF_10059-01 - Organisationsressourcen im Verzeichnisdienst hinzufügen
  ML-123627 - Organisationsressourcen im VZD-FHIR-Directory hinzufügen
  ML-132586 - TI-M Rohdatenerfassung und -lieferung
  ML-123654 - Suche im VZD-FHIR-Directory

  In diesem Anwendungsfall erfolgt gleichzeitig eine Prüfung des Berechtigungskonzept.
  Zusätzlich werden in diesem Feature File Anforderungen aus Feature File 7 (AF_10104) betrachtet,
  da sie Preconditions für den AF_10063 darstellen und so an dieser Stelle getestst werden.

  TF 1      HBA sendet Nachricht Chat/Raum (OrgUser - OrgUser)
  TF 2 & 3 User verlässt den Chat/Raum (OrgUser - OrgUser)

  @BP:P2P @Ctl:Raum @Ctl:MsgBackward @Ctl:OrgOnly
    @TCID:TIM_11_AF_11001 @PRIO:1 @TESTFALL:Positiv @STATUS:Implementiert
  Szenariogrundriss: 110.01 Events außerhalb einer Organisation - Raum - Test-Client "B" sendet eine Nachricht (OrgUser - OrgUser)
    Angenommen Es werden folgende Clients reserviert:
      | A | ORG_ADMIN | <ApiName1A> |
      | B | CLIENT    | <ApiName1B> |
      | C | ORG_ADMIN | <ApiName2A> |
      | D | CLIENT    | <ApiName2B> |
    Und        "A" erstellt einen Healthcare-Service "HealthcareServiceName1" und setzen einen Endpunkt auf "B"
    Und        "C" erstellt einen Healthcare-Service "HealthcareServiceName2" und setzen einen Endpunkt auf "D"
    Und        "B" erstellt einen Chat-Raum "TIM Testraum 1"
    Und        "B" lädt "D" über den HealthcareService "HealthcareServiceName2" in den Chat-Raum "TIM Testraum 1" ein
    Und        "D" erhält eine Einladung in Raum "TIM Testraum 1" von "B"
    Und        "D" bestätigt eine Einladung in Raum "TIM Testraum 1" von "B"
    Wenn       "D" sendet die Nachricht "Testnachricht 1" an den Raum "TIM Testraum 1"
    Dann       "B" empfängt eine Nachricht "Testnachricht 1" von "D" im Raum "TIM Testraum 1"

  #@Shuffle(true)
  #@MaxSameColumnProperty(ApiName2,homeserver,2)
    @Filter(ApiName1A.properties["homeserver"].equals(ApiName1B.properties["homeserver"]))
    @Filter(ApiName2A.properties["homeserver"].equals(ApiName2B.properties["homeserver"]))
    @Filter(!ApiName1B.properties["homeserver"].equals(ApiName2B.properties["homeserver"]))
    @AllowSelfCombine(false)
    @AllowDoubleLineup(true)
    @Filter(ApiName1A.hasTag("orgAdmin"))
    @Filter(ApiName2A.hasTag("orgAdmin"))
    @Filter(ApiName1B.hasTag("client"))
    @Filter(ApiName2B.hasTag("client"))
    @SoftFilter(ApiName1B.hasTag("prefIOP"))
    @SoftFilter(ApiName2B.hasTag("prefIOP"))

    Beispiele:
      | ApiName1A | ApiName1B | ApiName2A | ApiName2B |

  @BP:P2P @Ctl:Chat @Ctl:MsgForward @Ctl:OrgOnly
    @TCID:TIM_11_AF_11002 @PRIO:1 @TESTFALL:Positiv @STATUS:Implementiert
  Szenariogrundriss: 110.02 Events außerhalb einer Organisation - Chat - User verlässt den Chat (OrgUser)
    Angenommen Es werden folgende Clients reserviert:
      | A | ORG_ADMIN | <ApiName1A> |
      | B | CLIENT    | <ApiName1B> |
      | C | ORG_ADMIN | <ApiName2A> |
      | D | CLIENT    | <ApiName2B> |
    Und        "A" erstellt einen Healthcare-Service "HealthcareServiceName1" und setzen einen Endpunkt auf "B"
    Und        "C" erstellt einen Healthcare-Service "HealthcareServiceName2" und setzen einen Endpunkt auf "D"
    Wenn       "B" schreibt "D" über den Healthcare-Service "HealthcareServiceName2" direkt "Testnachricht 1"
    Und        "D" erhält eine Einladung von "B"
    Und        "D" bestätigt eine Einladung von "B"
    Dann       "D" empfängt eine Nachricht "Testnachricht 1" von "B"
    Wenn       "B" verlässt Chat mit "D"
    Dann       "D" bestätigt, dass "B" den Chat-Raum verlassen hat

  #@Shuffle(true)
  #@MaxSameColumnProperty(ApiName1,homeserver,2)
    @Filter(ApiName1A.properties["homeserver"].equals(ApiName1B.properties["homeserver"]))
    @Filter(ApiName2A.properties["homeserver"].equals(ApiName2B.properties["homeserver"]))
    @Filter(!ApiName1B.properties["homeserver"].equals(ApiName2B.properties["homeserver"]))
    @AllowSelfCombine(false)
    @AllowDoubleLineup(true)
    @Filter(ApiName1A.hasTag("orgAdmin"))
    @Filter(ApiName2A.hasTag("orgAdmin"))
    @Filter(ApiName1B.hasTag("client"))
    @Filter(ApiName2B.hasTag("client"))
    @SoftFilter(ApiName1B.hasTag("prefIOP"))
    @SoftFilter(ApiName2B.hasTag("prefIOP"))

    Beispiele:
      | ApiName1A | ApiName1B | ApiName2A | ApiName2B |

  @BP:P2P @Ctl:Raum @Ctl:MsgForward @Ctl:OrgOnly
    @TCID:TIM_11_AF_11003 @PRIO:1 @TESTFALL:Positiv @STATUS:Implementiert
  Szenariogrundriss: 110.03 Events außerhalb einer Organisation - Raum - User verlässt den Raum (OrgUser)
    Angenommen Es werden folgende Clients reserviert:
      | A | ORG_ADMIN | <ApiName1A> |
      | B | CLIENT    | <ApiName1B> |
      | C | ORG_ADMIN | <ApiName2A> |
      | D | CLIENT    | <ApiName2B> |
    Und        "A" erstellt einen Healthcare-Service "HealthcareServiceName1" und setzen einen Endpunkt auf "B"
    Und        "C" erstellt einen Healthcare-Service "HealthcareServiceName2" und setzen einen Endpunkt auf "D"
    Und        "B" erstellt einen Chat-Raum "TIM Testraum 1"
    Und        "B" lädt "D" über den HealthcareService "HealthcareServiceName2" in den Chat-Raum "TIM Testraum 1" ein
    Und        "D" erhält eine Einladung in Raum "TIM Testraum 1" von "B"
    Und        "D" bestätigt eine Einladung in Raum "TIM Testraum 1" von "B"
    Wenn       "D" sendet die Nachricht "Testnachricht 1" an den Raum "TIM Testraum 1"
    Dann       "B" empfängt eine Nachricht "Testnachricht 1" von "D" im Raum "TIM Testraum 1"
    Wenn       "D" verlässt Raum "TIM Testraum 1"
    Dann       "B" bestätigt, dass "D" den Raum "TIM Testraum 1" verlassen hat

  #@Shuffle(true)
  #@MaxSameColumnProperty(ApiName2,homeserver,2)
    @Filter(ApiName1A.properties["homeserver"].equals(ApiName1B.properties["homeserver"]))
    @Filter(ApiName2A.properties["homeserver"].equals(ApiName2B.properties["homeserver"]))
    @Filter(!ApiName1B.properties["homeserver"].equals(ApiName2B.properties["homeserver"]))
    @AllowSelfCombine(false)
    @AllowDoubleLineup(true)
    @Filter(ApiName1A.hasTag("orgAdmin"))
    @Filter(ApiName2A.hasTag("orgAdmin"))
    @Filter(ApiName1B.hasTag("client"))
    @Filter(ApiName2B.hasTag("client"))
    @SoftFilter(ApiName1B.hasTag("prefIOP"))
    @SoftFilter(ApiName2B.hasTag("prefIOP"))

    Beispiele:
      | ApiName1A | ApiName1B | ApiName2A | ApiName2B |